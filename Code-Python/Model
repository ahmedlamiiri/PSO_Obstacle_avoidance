import numpy as np
import matplotlib.pyplot as plt #bibliothéque permet de créer des graphiques et visualisations
from PIL import Image  #bibliothéque permet de charger l'image


class TerrainModel:
         # Constructeur pour initialiser les attributs
    def __init__(self, terrain_file, threats, bounds, start_location, end_location, n):    #self permet d'accéder aux attributs
        self.H = np.array(Image.open(terrain_file))
        self.H[self.H < 0] = 0

        self.MAPSIZE_Y, self.MAPSIZE_X = self.H.shape
        self.X, self.Y = np.meshgrid(np.arange(1, self.MAPSIZE_X + 1), np.arange(1, self.MAPSIZE_Y + 1))

        self.threats = threats
        self.bounds = bounds
        self.start_location = start_location
        self.end_location = end_location
        self.n = n

    def plot(self):
        fig = plt.figure(figsize=(10, 7))    #crée une nouvelle figure vide pour ajouter des sous graphiques
                                               #figsize(10,7) la taille de figure (largeur, hauteur)
        ax = fig.add_subplot(111, projection='3d')


        ax.plot_surface(self.X, self.Y, self.H, cmap='summer', edgecolor='none', alpha=0.7)    # Tracé du terrain
                                                                                            # summer :Les hauteurs faibles seront colorées en vert.
                                                                                            #Les hauteurs plus élevées seront colorées en jaune.
                                                                                            # none :supprime les lignes entre chaque carreau de surface
                                                                                           #alpha 0.7 : transparence de surface est 70%
        h = 250  
        # Ajouter des menaces sous forme de cylindres
        for threat in self.threats:
            threat_x, threat_y, threat_z, threat_radius = threat
            theta = np.linspace(0, 2 * np.pi, 100)
            z = np.linspace(threat_z, threat_z + h, 2)
            theta, z = np.meshgrid(theta, z)
            x = threat_radius * np.cos(theta) + threat_x
            y = threat_radius * np.sin(theta) + threat_y
            ax.plot_surface(x, y, z, color='red', alpha=0.3, edgecolor='none')


        ax.set_xlabel('x [m]')
        ax.set_ylabel('y [m]')
        ax.set_zlabel('z [m]')
        plt.show()



terrain_file = 'ChrismasTerrain.tif'
threats = [
    (400, 500, 100, 80), #les coordonnees des menaces (x,y,z,r)
    (600, 200, 150, 70),
    (500, 350, 150, 80),
    (300, 200, 150, 80),
    (700, 550, 150, 70),
    (650, 750, 150, 80)
]
bounds = {'xmin': 1, 'xmax': 1000, 'ymin': 1, 'ymax': 1000, 'zmin': 100, 'zmax': 200}  #limite minimale et maximale de la terrain (x, y , z)
start_location = np.array([200, 100, 150])   # coordonnee de la point de départ
end_location = np.array([800, 800, 150])  #coordonnee de la point finale
n = 22


model = TerrainModel(terrain_file, threats, bounds, start_location, end_location, n)  #création du modéle
model.plot()  #affichage de modéle
